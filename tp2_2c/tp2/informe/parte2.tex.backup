
\subsection{Ejercicios}
\begin{itemize}
 \item 
\textbf{Ejercicio 2}
Deber\'{a}n, a su vez, implementar un test para su implementaci\'{o}n de Read-Write Locks (RWLockTest)
que involucre la creaci\'{o}n de varios threads lectores y escritores donde cada uno de ellos trate
de hacer un lock sobre un mismo recurso y se vea que no haya deadlocks ni inanici\'{o}n (archivo
backend-multi/RWLockTest.cpp).
\end{itemize}

\subsection{Resultados y Conclusiones}


\subsubsection[Resoluci贸n Ejercicio 2]{Ejercicio 2}

\indent Para mostrar esto creamos una funci\'{o}n que crea varios threads de escritura y lectura. Cada tipo de thread 
llama a una funci\'{o}n distinta e imprime por pantalla su ID y el valor de una variable, en caso de los threads de 
escritura estos indican el nuevo valor de la variable mientras que los de lectura imprimen el valor actual de la misma.\\
\indent Para ello se utilizan las siguientes variables y funciones:\\
\begin{itemize}
\item int NUM_THREADS : Indica la cantidad de threads a crear.
\item int variable : Esta es el recurso que los threads van a manejar ( ya sea para leerlo o modificarlo).
\item RWLock para_variable : Este lock se usa cuando un thread quiere manejar el recurso.
\item int array[NUM_THREADS] : Un array de tama\~{n}o igual a cantidad de threads, Se usa para darle a cada thread un ID. 
La posici\'{o}n del array va a corresponder al thread creado.
\item pthread_t threads[NUM_THREADS] : Un array de tama\~{n}o igual a cantidad de threads a crear, se usa para crear los threads.
\item void *soy_lector(void *p_numero) : Funci\'{o}n que va a correr el thread que lea el recurso.
\item void *soy_escritor(void *p_numero) : Funci\'{o}n a correr por los threads que modifiquen el valor del recurso.
\end{itemize}

\begin{verbatim}
for (i = 0; i < NUM_THREADS; ++i){
  if(!(i % 2)){
    pthread_create(&threads[i], NULL, soy_escritor, &array[i]);
  }else{
    pthread_create(&threads[i], NULL, soy_lector, &array[i]);
  }
}
\end{verbatim}

Este ciclo es el encargado de crear todos los threads, si el valor de i es impar se crea un thread que va a correr la funci\'{o}n 
"soy_escritor", si es par ejecuta "soy_lector". 
\\

A continuaci贸n, mostraremos esta secci贸n de c贸digo:\\
\begin{verbatim}
\*creacion de arreglo de threads y arreglo de estructuras thread_data *\

                      pthread_t threads[NUM_THREADS];
                      struct thread_data td[NUM_THREADS];
                      
\* carga por cada iteracion de ciclo y creacion del thread *\

                      td[i].socket_cliente_struct = socketfd_cliente;
                      td[i].rw_lock = read_write_lock;
                      pthread_create(&threads[i], NULL, &atendedor_de_jugador, (void *)&td[i]);
                      i++;
\end{verbatim}






